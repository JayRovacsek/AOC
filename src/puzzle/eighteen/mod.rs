mod test;

use rayon::prelude::*;
use std::collections::HashSet;
use std::fs;

#[derive(Debug, PartialEq, Eq, Hash, Clone)]
struct Point {
    x: usize,
    y: usize,
    wall: bool,
    key: Option<char>,
    door: Option<char>,
    start: bool,
}

impl Point {
    fn from_char(input: char, x: usize, y: usize) -> Point {
        Point {
            x,
            y,
            wall: input == '#',
            key: if input.is_ascii_lowercase() {
                Some(input)
            } else {
                None
            },
            door: if input.is_ascii_uppercase() {
                Some(input)
            } else {
                None
            },
            start: input == '@',
        }
    }

    fn traversable_immediate_points(&self, points: &HashSet<Point>) -> HashSet<Point> {
        let a: Option<&Point> = points
            .iter()
            .find(|p| !p.wall && p.door.is_none() && p.x == (self.x + 1) && p.y == self.y);
        let b: Option<&Point> = points
            .iter()
            .find(|p| !p.wall && p.door.is_none() && p.x == (self.x - 1) && p.y == self.y);
        let c: Option<&Point> = points
            .iter()
            .find(|p| !p.wall && p.door.is_none() && p.x == self.x && p.y == (self.y + 1));
        let d: Option<&Point> = points
            .iter()
            .find(|p| !p.wall && p.door.is_none() && p.x == self.x && p.y == (self.y - 1));

        vec![a, b, c, d]
            .into_iter()
            .filter(|x| x.is_some())
            .map(|x| x.unwrap())
            .cloned()
            .collect()
    }

    fn traversable_points(
        &self,
        points: &HashSet<Point>,
        mut traversed_points: HashSet<Point>,
    ) -> HashSet<Point> {
        let inital_size = traversed_points.len();
        let tp = self.traversable_immediate_points(points);
        traversed_points.extend(tp.clone());

        if inital_size == traversed_points.len() {
            traversed_points
        } else {
            for t in &tp {
                let more_tp = t.traversable_points(points, traversed_points.clone());
                traversed_points.extend(more_tp);
            }
            traversed_points
        }
    }

    fn distance(
        &self,
        target: &Point,
        points: &HashSet<Point>,
        visited: HashSet<Point>,
        count: usize,
    ) -> usize {
        let traversable_immediate_points = self.traversable_immediate_points(points);
        if !traversable_immediate_points.iter().any(|p| p == target) {
            traversable_immediate_points
                .iter()
                .filter(|p| {
                    manhattan_distance((p.x as i32, p.y as i32), (target.x as i32, target.y as i32))
                        <= traversable_immediate_points
                            .iter()
                            .map(|x| {
                                manhattan_distance(
                                    (x.x as i32, x.y as i32),
                                    (target.x as i32, target.y as i32),
                                )
                            })
                            .min()
                            .unwrap()
                            + 1
                        && !visited.contains(*p)
                })
                .map(|p| {
                    let mut v = visited.clone();
                    v.insert(p.clone());
                    p.distance(target, points, v, count + 1)
                })
                .min()
                .unwrap_or(0)
        } else {
            count + 1
        }
    }

    fn distance_with_draw(
        &self,
        target: &Point,
        points: &HashSet<Point>,
        visited: HashSet<Point>,
        count: usize,
    ) -> usize {
        let traversable_immediate_points = self.traversable_immediate_points(points);
        if !traversable_immediate_points.iter().any(|p| p == target) {
            let tp = traversable_immediate_points
                .iter()
                .filter(|p| {
                    (manhattan_distance(
                        (p.x as i32, p.y as i32),
                        (target.x as i32, target.y as i32),
                    ) <= traversable_immediate_points
                        .iter()
                        .map(|x| {
                            manhattan_distance(
                                (x.x as i32, x.y as i32),
                                (target.x as i32, target.y as i32),
                            )
                        })
                        .min()
                        .unwrap()
                        + 1)
                        && !visited.contains(&p)
                })
                .cloned()
                .collect::<HashSet<Point>>();

            // let expanded_visited: HashSet<Point> = visited.union(&tp).cloned().collect();

            tp.iter()
                .map(|p| {
                    p.distance_with_draw(
                        target,
                        points,
                        visited.union(&tp).cloned().collect(),
                        count + 1,
                    )
                })
                .min()
                .unwrap_or(0)
        } else {
            draw(target.key.unwrap(), points, &visited);
            count + 1
        }
    }
}

fn draw(key: char, points: &HashSet<Point>, visited: &HashSet<Point>) {
    let width = points.iter().max_by(|x, y| x.x.cmp(&y.x)).unwrap().x;
    let height = points.iter().max_by(|x, y| x.y.cmp(&y.y)).unwrap().y;
    let mut contents: String = String::new();
    for x in 0..=width {
        for y in 0..=height {
            let c = points.iter().find(|z| z.x == x && z.y == y).unwrap();
            contents += if visited.iter().any(|z| z.x == x && z.y == y) {
                "%"
            } else if c.wall {
                "â–ˆ"
            } else {
                " "
            };
            if y == height {
                contents += "\n"
            };
        }
    }
    fs::write(format!("./results/path_of_{}_key.txt", key), contents)
        .expect("Unable to write file");
}

fn manhattan_distance(x: (i32, i32), y: (i32, i32)) -> usize {
    ((x.0 - y.0).abs() + (x.1 + y.1).abs()) as usize
}

fn generate_points(input: &str) -> HashSet<Point> {
    input
        .split('\n')
        .collect::<Vec<&str>>()
        .par_iter()
        .enumerate()
        .map(|x| {
            x.1.chars()
                .collect::<Vec<char>>()
                .iter()
                .enumerate()
                .map(|y| Point::from_char(*y.1, x.0, y.0))
                .collect::<Vec<Point>>()
        })
        .flatten()
        .collect()
}

// 3201 non-walls, 3360 walls

pub fn solve() {
    let points = generate_points(INPUT);
    let p = points.iter().find(|x| x.start).unwrap();
    let tp = p.traversable_points(&points, HashSet::new());
    println!(
        "Number of traversable points from {:?} are: {}\nKeys reachable: {:?}",
        p,
        tp.len(),
        tp.iter()
            .filter(|x| x.key.is_some())
            .collect::<HashSet<&Point>>()
    );

    println!(
        "Found {} non walls, and {} walls",
        points.iter().filter(|x| !x.wall).count(),
        points.iter().filter(|x| x.wall).count()
    );

    tp.par_iter().filter(|x| x.key.is_some()).for_each(|x| {
        println!("Attempting to find a way to key: {:?}", x.key);
        println!(
            "Testing distance between start and key: {:?}\nFound distance to be: {:?}",
            x.key,
            p.distance_with_draw(x, &points, HashSet::new(), 0)
        );
    })
}

const INPUT: &str =
    "#################################################################################
#.....#...............#.....#.A.#.......#.....#e..............#.....#...........#
#.###.#########.#####.###.#.###.#.###.#.###.#.###.###########.#.#.###.#####.#####
#.#.#.....#...#.#...#.#...#.....#.#.#.#.#...#..m#...#.......#.#.#.#...#.#...#...#
#.#.#####.#.#.#.#.###.#.#########.#.#.###.#####.###.#.#######.###.#.###.#N###.#.#
#.#.#...#...#...#...#.#.....T.......#...#.#...#.....#.#.....#.#...#.....#.#...#.#
#.#.#.#.###########.#.#.###############.#.#.#.#######.#.###.#.#.#.#####.#.#.###.#
#.#...#.......#.....#.#.......#.....#...#.#.#...#.........#j....#.#...#.#.#.#...#
#.###########.#.#.#.#.#########.###.#.#.#.#.###.#.#########.#####.###.#.#.#.#.#.#
#.#.....#...#.#.#.#.#...........#...#.#.#.#...#.#.#...#...#.#...#...#.#.#...#.#.#
#.#P###.#D#.#.#.#.###############.###.#.#.###.#.#.###.#.#.###.#.###.#.#.#####.###
#...#...#.#.#u..#.......#...#.....#...#.#.#...#.......#.#.....#...#...#.....#...#
#####.###.#.#######.###.#.###.#######.#.#.#########.###.#########.#########.###.#
#...#.#...#g......#...#.#...#.#.....#.#.#.#...#...#.#...#.......#.#.........#...#
#.#.#.#.#########.###.#.###.#.###.#.#.#.#.#.#.#.#.###.#######.#.#.#.#########O#.#
#.#...#..d#.....#...#.#.....#.....#...#.#...#...#.....#.....#.#.#...#.....#...#.#
#.#######.#.###F###.#.#################.#.###############.#.#.#.#######.#.#.###.#
#.....#...#..h#...#.#.............#.....#.#.......#.......#...#.....#...#.#.#...#
#.###.#H#####.#.###G#.#######.#####.#####.###.#.#.#.###.###########.#.###.#.#####
#.#.#.#.......#.#...#.....#...#...#.#...#...#.#.#.#...#.#...#.....#...#.#.#.....#
#.#.#.#########.#.#########.###.#.#.###.###.#.#.#.#####.#.#.#####.#####.#.#####.#
#...#.....#.....#b..#...#...#...#...#...#...#.#.#.....#...#.#y..#.......#.....#.#
###.#####.#.#######.###B#.#.#.#######.#.#.#####.#####.#.###.###.#####.#.#.#####.#
#...#...I.#f......#.....#.#.#.#...#...#.#...#...#...#.#.#.....#.....#.#...#.....#
#####.###########.#######.###.#.###.#.#####.#.###.###.###.#########.#######.#####
#o....#k........#.#.#.......#.#.#...#...#.#.#.#.....#.#...#.......#.......K.#...#
#.#####.###.#####.#.#.#####.#.#.#.#####.#.#.#.###.#.#.#.###.###.###############.#
#.#.......#...#.C.#.....#...#.#...#...#.#...#...#.#.#.#...#...#.....#...........#
#.#.#########.#.#########.###.###.#.###.#.#####.#.#.#.###.###.#####.#.#.#######.#
#...#l........#...#.....#...#...#...#...#.......#.#...#...#...#...#...#.X.#...#.#
#.###.#.#########.#V###.###.###.#####.###########.#####.###.###.#########.#.#.#.#
#...#.#.#.....#...#.#.#.#...#.#.....#...#.......#...#...#...#...........#.#.#.#.#
#####.#.#.###.#.###.#.#.#.#.#.#####.###.#.#####.###.#.#.#.###.#######.###.#.#.#W#
#.....#.#.#r#.#.#...#.#.#.#.#.#...#...#.#.#...#...#.#.#.#...#.......#...#.#.#.#.#
#.#######.#.#.#.###.#.#.#.#.#.#.#.###.#.#.###.###.#.#.#.###.###########.#.#.#.#.#
#.........#.#.#.#s..#...#.#.Q.#.#.#...#.#...#...#...#.#.............#...#.#.#...#
#.#########.#.#.#.###.###.#.###.#.#.###.###.#.#.#####.#######.#####.#.###.#.#####
#...#...#...#.#...#...#...#.#...#...#...#.#.#.#.....#...#...#.#...#...#...#...#.#
###.#Y#.###.#.#####.###.#####.#########.#.#.###.###.#####.#.###.#.#####.#####.#.#
#.....#.....#.......#...........................#.........#....q#.......#.......#
#######################################.@.#######################################
#...#.#.................#..z..............#.......#.............#...............#
#.#.#.#.#.#############.#.#.###########.#.#.#.#####.#####.#####.#.###.#########.#
#.#...#.#.#...#.#.....#.#.#.#.....#...#.#...#.#...Z.....#.#.....#.#.#.#.......#.#
#.#####.#.#.#.#.#.#.#.#.###.#.#####.#.#.#.###.#.#########.#######.#.#.#####.###.#
#.#...#.#...#.#...#.#x#.#...#.#.....#.#.#...#.....#.....#.#...#.....#.#...#.....#
#.#.#.#.#####.#####.###.#.###.#.#####.#.###.#######.###.#.#.#.#.#####.#.#.#####.#
#w..#...#...#.....#.#.....#...#.#.....#.#.#...#.....#.#...#.#...#..v#.#.#.....#.#
#.#######.#.#####.#.#.#####.###.#.#####.#.###.#.#####.#.###.#####.#.#.#.#####.###
#.#.......#.#.#...#.#.#...#.#...#.#...#.#...#.#.#.......#...#...#.#.#.#.#...#...#
#.###.#.###.#.#.###.#.#.#.#.#.###.#.#.#.#.###.#.###.#####.###.#.#.#.#.#.###.###.#
#...#.#...#...#.#.#...#.#.#...#.#.#.#...#...#.#...#.#...#.#...#.R.#.#.........#.#
###.#####.###.#.#.#.###.#.###.#.#.#.#####.#.#.###.#.#.#.#.#.#######.#.#########.#
#.#...#...#.#.#.#.....#.#...#...#.......#.#.#...#.#...#.#.#.#...#...#.#.........#
#.###.#.###.#.#.#######.###.#.#########.#.#.###.#.#######.#.#.###.###.#.#######.#
#...#...#...#.#.........#...#.#...#.....#.#...#.#.........#.#.#...#...#.#.......#
#.#######.#.#.###########.#####.#.#####.###.###.###########.#.#.#######.#########
#.........#.#.#.........#.......#.#...#.#...#...#...........#.#.#.....#.........#
#.###.#######.#.###.#####.#####.#.#.#.###.#.#.###.###########.#.#.###S#########.#
#...#.......#...#...#...#.#...#.#...#...#.#.#...#.....L.#.....#...#...#...#...#.#
#.#########.#####.###.#.###.#.###.#####.#.#####.#######.#.#########.###.#.#.#.#.#
#.#.......#.#...#.#.#.#.#...#...#...#...#...........#...#...#.#....c#...#...#.#.#
###.#####.#.#.#.#.#.###.#.#####.#####.###.###########.#####.#.#.#####.#######.#.#
#...#.......#.#...#...#...#...#...#...#.#...#.........#.....#...#.......#.......#
#.###.#######.#####.#######.#.###.#.###.###.#.###########.#.#########.#.#######.#
#.#.#.#...#...#.............#...#...#...#...#.............#.........#.#.#.....#.#
#.#.#.#.#.#.###########.#####.#.#####.###.#########################.###.#.###.#.#
#.#...#.#.#.....#.....#...#...#.#.#.....#.....#...#.......#.......#...#...#...#.#
#.#####.#.#####.#.###.#####.###.#.#.###.#####.#.###.###.###.#####.###.#####.#####
#.......#...#.#...#.#.#.....#.#.#...#...#...#.#.#.....#.........#...#.....#.....#
#.#######.#.#.#####E#.#.#####.#.#.###.#.#.#.#.#.#.#############.#.#.#####.###.#.#
#...#.....#...#...#...#.#.....#.#...#.#.#.#...#.....#..a#.....#.#.#...#.#...#.#.#
#####.#######.#.###.###.#.###.#.#.###.#.#.###########.#.#.###.###.###.#.###.###.#
#...#.#.#...#.#.#...#...#.#...#.#.#...#.#.....#.....#.#.#.#.#...#...#...#.#...#.#
#.#.#.#.#.#.#.#.#.###.#.#.#.#.#.###.###.#####.#.###.#.#.#.#.###.###.###.#.###.#.#
#.#.#.#.#.#.....#.#...#.#.#.#.#.....#.#.#.....#.#...#.#...#...#...#.#.#.#...#..i#
#.#.#.#.#.#######.#####.###.#########.#.#.#####U#.###.#######.###.#.#.#.#.#.#####
#.#n..#.......#...#...#...#.#...#.......#.......#t#...#.........#.#.#.#...#.#...#
#.#############.###.#.###.#.#.#.#.###############.#.###.#.#######.#.#.#####.#.#.#
#...............J...#.....#...#.........#...........#...#.........M.#..p......#.#
#################################################################################";
